import { PropertyOrFunc, StringOrNumber, Subset, KeyOfType } from './types';
/**
 * Checks if the type is a number, string, or boolean
 * @param obj - The object to check
 * @returns
 */
export declare function isPrimitive(obj: any): boolean;
/**
 * Checks if the obj is of type 'boolean'
 * @param obj - the object to check
 * @returns
 */
export declare function isBoolean(obj: any): boolean;
/**
 * Checks if the object is null or undefined
 * @param obj - Object to check
 * @returns
 */
export declare function isNullOrUndefined(obj: unknown): boolean;
/**
 * Checks if the object is notEmpty as isNaN('') interprets as 0, and type is number or bigint
 * @param obj - Object to check
 * @returns
 */
export declare function isNumber(obj: any): boolean;
/**
 * Checks if the object is of type 'string'
 * @param obj - Object to check
 * @returns
 */
export declare function isString(obj: any): boolean;
/**
 * Checks if the obj is of type 'object'
 * @param obj The object to check
 * @returns
 */
export declare function isObject(obj: any): boolean;
/**
 * Check if the obj is of type function
 * @param obj - The object to check
 * @returns
 */
export declare function isFunction(obj: any): boolean;
/**
 * Checks if the obj is null or undefined or an array | string with a length of zero.
 * @param obj - The object check
 * @returns
 */
export declare function isEmpty(obj: any): boolean;
/**
 *
 * @param obj - The object to check if it's !isEmpty
 * @returns
 */
export declare function notEmpty(obj: any): boolean;
/**
 * Check if any of the values of T are isEmpty
 * @param items - The items to check if isEmpty
 * @returns
 */
export declare function anyEmpty<T>(...items: T[]): boolean;
/**
 * Checks if all values of T are isEmpty
 * @param items - The items to check if the values are empty using
 * @returns
 */
export declare function allEmpty<T>(...items: T[]): boolean;
/**
 * Checks if the obj has keys associated with it that's not an array
 * @param obj - The object check for keys
 * @returns boolean
 */
export declare function hasKeys(obj: any): boolean;
/**
 *
 * @param item - The object checked for the nested value
 * @param property - the property or dot notation value of the property as string e.g. { image: { url: string, height: number, width: number } } and syntax would be 'image.url' or 'image.height'
 * @returns
 */
export declare function getNestedValue<T>(item: any, property: string): T;
/**
 *
 * @param item - The object to find the property
 * @param propName - The string value of the property, may contain dot notation for nesting properties e.g. { image: { url: string, height: number, width: number } } and syntax would be 'image.url' or 'image.height'
 * @param defaultValue - The default value if the property is null or undefined
 * @returns
 */
export declare function defaultIfEmpty<T>(item: any, propName: string, defaultValue?: T): T;
/**
 *
 * @param obj - The object we want to remove the property
 * @param propertyName - the name of the property to remove
 * @returns
 */
export declare function removeProperty<T, R = T | Partial<T>>(obj: T | Partial<T>, propertyName: keyof T): R;
/**
 *
 * @param items - The array you want to group give the propName or function to group
 * @param propName - The name of the property or function which groups the values by key name
 * @returns Record<string, T[]>
 */
export declare function groupDictionary<T>(items: T[], propName: PropertyOrFunc<T, StringOrNumber>): Record<string, T[]>;
/**
 * Converts a partial object of type T to provide the keypath values down to the properties that are either a string, number, or boolean
 *
 * @param item - a partial object consisting of the values to be patched.
 * @returns Record<string, unknown>
 */
export declare function covertPartialToDotPathKeys<T>(item: Partial<T>): Record<string, unknown>;
/**
 * Converts an object into querystring parameters for a url
 * @param obj - The object to convert to querystring parameters
 * @returns a querystring of all the parameters encoded for a url
 */
export declare function convertToQueryStringParams(obj: Record<string, StringOrNumber | boolean>): string;
/**
 * Updates an object with a partial object
 * undefined properties in the obj that exist on the patch value
 * will be added e.g. obj: { id: '1234' }, patchValue: { name: { first: 'hootie', last: 'blowfish' } }
 * { id: '1234', name: { first: 'hootie', last: 'blowfish' } }
 * @param obj The object to receive the updates
 * @param patchValue the updated Subset<T> of the obj T
 * @returns
 */
export declare function patchValues<T extends object>(obj: T, patchValue: Subset<T>): T;
/**
 *
 * @param obj - The object where properties are being picked
 * @param keys - The properties of the object being picked
 * @returns The picked object of T with properties of K Pick<T, K>
 */
export declare function pick<T, K extends KeyOfType<T>>(obj: T, keys: K[]): Pick<T, K>;
/**
 *
 * @param obj - The object where properties are omitted
 * @param keys - The keys to omit
 * @returns The object T with omitted keys K
 */
export declare function omit<T, K extends KeyOfType<T>>(obj: T, keys: K[]): Omit<T, K>;
