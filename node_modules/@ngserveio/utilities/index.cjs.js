'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var luxon = require('luxon');

function isType(obj, type) {
    return typeof obj === type;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function stopOnValue(item, propName) {
    const value = item[propName];
    return value === undefined || isPrimitive(value);
}
function getKeyPaths(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
item, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
pathComplete, propName) {
    for (const prop in item) {
        if (item[prop] === undefined) {
            continue;
        }
        const path = propName ? `${propName}.${prop}` : prop;
        if (stopOnValue(item, prop)) {
            pathComplete(path, item[prop]);
        }
        else {
            getKeyPaths(item[prop], pathComplete, path);
        }
    }
}
/**
 * Checks if the type is a number, string, or boolean
 * @param obj - The object to check
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isPrimitive(obj) {
    return isNumber(obj)
        || isString(obj)
        || isBoolean(obj);
}
/**
 * Checks if the obj is of type 'boolean'
 * @param obj - the object to check
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isBoolean(obj) {
    return typeof obj === 'boolean';
}
/**
 * Checks if the object is null or undefined
 * @param obj - Object to check
 * @returns
 */
function isNullOrUndefined(obj) {
    return obj === undefined || obj === null;
}
/**
 * Checks if the object is notEmpty as isNaN('') interprets as 0, and type is number or bigint
 * @param obj - Object to check
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isNumber(obj) {
    // isNaN('') interprets as 0
    return notEmpty(obj) && (isType(obj, 'number') || isType(obj, 'bigint'));
}
/**
 * Checks if the object is of type 'string'
 * @param obj - Object to check
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isString(obj) {
    return isType(obj, 'string');
}
/**
 * Checks if the obj is of type 'object'
 * @param obj The object to check
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isObject(obj) {
    return isType(obj, 'object');
}
/**
 * Check if the obj is of type function
 * @param obj - The object to check
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isFunction(obj) {
    return isType(obj, 'function');
}
/**
 * Checks if the obj is null or undefined or an array | string with a length of zero.
 * @param obj - The object check
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isEmpty(obj) {
    return isNullOrUndefined(obj)
        || ((Array.isArray(obj) || isString(obj)) && obj.length === 0);
}
/**
 *
 * @param obj - The object to check if it's !isEmpty
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function notEmpty(obj) {
    return !isEmpty(obj);
}
/**
 * Check if any of the values of T are isEmpty
 * @param items - The items to check if isEmpty
 * @returns
 */
function anyEmpty(...items) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return items.some(item => isEmpty(item));
}
/**
 * Checks if all values of T are isEmpty
 * @param items - The items to check if the values are empty using
 * @returns
 */
function allEmpty(...items) {
    return items.every(p => isEmpty(p));
}
/**
 * Checks if the obj has keys associated with it that's not an array
 * @param obj - The object check for keys
 * @returns boolean
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function hasKeys(obj) {
    return !isNullOrUndefined(obj) &&
        !Array.isArray(obj)
        && isObject(obj)
        && Object.keys(obj).length > 0;
}
/**
 *
 * @param item - The object checked for the nested value
 * @param property - the property or dot notation value of the property as string e.g. { image: { url: string, height: number, width: number } } and syntax would be 'image.url' or 'image.height'
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getNestedValue(item, property) {
    if (anyEmpty(item, property)) {
        return null;
    }
    const properties = property.split('.');
    for (let i = 0; i < properties.length; i++) {
        const propertyName = properties[i];
        item = item[propertyName];
        if (isNullOrUndefined(item)) {
            return null;
        }
    }
    return item;
}
/**
 *
 * @param item - The object to find the property
 * @param propName - The string value of the property, may contain dot notation for nesting properties e.g. { image: { url: string, height: number, width: number } } and syntax would be 'image.url' or 'image.height'
 * @param defaultValue - The default value if the property is null or undefined
 * @returns
 */
function defaultIfEmpty(item, propName, defaultValue = null) {
    if (anyEmpty(item, propName)) {
        return defaultValue;
    }
    const value = getNestedValue(item, propName);
    return isNullOrUndefined(value)
        ? defaultValue
        : value;
}
/**
 *
 * @param obj - The object we want to remove the property
 * @param propertyName - the name of the property to remove
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function removeProperty(obj, propertyName) {
    return Object.keys(obj).reduce((currentValue, key) => {
        if (key !== propertyName) {
            currentValue[key] = obj[key];
        }
        return currentValue;
    }, {});
}
/**
 *
 * @param items - The array you want to group give the propName or function to group
 * @param propName - The name of the property or function which groups the values by key name
 * @returns Record<string, T[]>
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function groupDictionary(items, propName) {
    const runFunction = isFunction(propName);
    return items.reduce((previousValue, currentValue) => {
        const key = runFunction
            ? propName(currentValue)
            : currentValue[propName];
        return {
            ...previousValue,
            [key]: [
                ...(previousValue[key] || []),
                currentValue
            ]
        };
    }, {});
}
/**
 * Converts a partial object of type T to provide the keypath values down to the properties that are either a string, number, or boolean
 *
 * @param item - a partial object consisting of the values to be patched.
 * @returns Record<string, unknown>
 */
function covertPartialToDotPathKeys(item) {
    let updateObj = {};
    getKeyPaths(item, (path, value) => {
        updateObj = {
            ...updateObj,
            [path]: value
        };
    });
    return updateObj;
}
/**
 * Converts an object into querystring parameters for a url
 * @param obj - The object to convert to querystring parameters
 * @returns a querystring of all the parameters encoded for a url
 */
function convertToQueryStringParams(obj) {
    return Object.keys(obj || {}).map(key => {
        return `${key}=${encodeURIComponent(obj[key])}`;
    }).join('&');
}
/**
 * Updates an object with a partial object
 * undefined properties in the obj that exist on the patch value
 * will be added e.g. obj: { id: '1234' }, patchValue: { name: { first: 'hootie', last: 'blowfish' } }
 * { id: '1234', name: { first: 'hootie', last: 'blowfish' } }
 * @param obj The object to receive the updates
 * @param patchValue the updated Subset<T> of the obj T
 * @returns
 */
function patchValues(obj, patchValue) {
    const patchKeys = Object.keys(patchValue);
    return patchKeys.reduce((currentObj, patchKey) => {
        const value = patchValue[patchKey];
        const objValue = defaultIfEmpty(currentObj, patchKey, undefined);
        return {
            ...currentObj,
            [patchKey]: value !== null && isObject(value) && !Array.isArray(value)
                ? patchValues(objValue, value)
                : value
        };
    }, { ...obj });
}
/**
 *
 * @param obj - The object where properties are being picked
 * @param keys - The properties of the object being picked
 * @returns The picked object of T with properties of K Pick<T, K>
 */
function pick(obj, keys) {
    return Object.keys(obj).filter(key => keys.includes(key)).reduce((returnValue, key) => {
        return {
            ...returnValue,
            [key]: obj[key]
        };
    }, {});
}
/**
 *
 * @param obj - The object where properties are omitted
 * @param keys - The keys to omit
 * @returns The object T with omitted keys K
 */
function omit(obj, keys) {
    return Object.keys(obj).filter(key => !keys.includes(key)).reduce((returnValue, key) => {
        return {
            ...returnValue,
            [key]: obj[key]
        };
    }, {});
}

function groupBy(value, propName) {
    if (isEmpty(propName)) {
        throw new Error('Invalid Argument: propName must be a string of function that returns a string.');
    }
    let grouped = {};
    const isFunc = isFunction(propName);
    const keyFunc = isFunc ? propName : null;
    if (!isEmpty(value)) {
        grouped = value.reduce((prev, cur) => {
            const propValue = isFunc ? keyFunc(cur) : cur[propName];
            if (!prev[propValue]) {
                prev[propValue] = [cur];
            }
            else {
                prev[propValue].push(cur);
            }
            return prev;
        }, {});
    }
    return Object.keys(grouped).map(key => ({ key, value: grouped[key] }));
}
function sortBy(value, propName, order) {
    if (defaultIfEmpty(value, 'length', 0) === 0) {
        return [];
    }
    const isFunc = isFunction(propName);
    value.sort((item1, item2) => {
        let value1 = item1;
        let value2 = item2;
        if (notEmpty(propName)) {
            if (isFunc) {
                value1 = propName(item1);
                value2 = propName(item2);
            }
            else {
                value1 = getNestedValue(item1, propName);
                value2 = getNestedValue(item2, propName);
            }
        }
        if (value1 === value2) {
            return 0;
        }
        const index = value1 > value2 ? -1 : 1;
        return order === 'asc' ? index * -1 : index;
    });
    return value;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function toDictionary(objects, propName) {
    const propNameIsString = isString(propName);
    return objects.reduce((previousValue, currentValue) => {
        const key = propNameIsString
            ? currentValue[propName]
            : propName(currentValue);
        previousValue[key] = currentValue;
        return previousValue;
    }, {});
}
function chunkMap(items, chunkSize = 500, mapFunc) {
    const numberOfChunks = Math.ceil(items.length / chunkSize);
    const chunks = [];
    const isMapFunction = isFunction(mapFunc);
    for (let i = 0; i < numberOfChunks; i++) {
        const batchIndex = i * chunkSize;
        const itemChunk = items.slice(batchIndex, batchIndex + chunkSize);
        if (isMapFunction) {
            chunks.push(mapFunc(itemChunk, i));
        }
        else {
            chunks.push(itemChunk);
        }
    }
    return chunks;
}
async function chunkAsync(items, chunkSize, func) {
    const numberOfChunks = Math.ceil(items.length / chunkSize);
    for (let i = 0; i < numberOfChunks; i++) {
        const batchIndex = i * chunkSize;
        const itemChunk = items.slice(batchIndex, batchIndex + chunkSize);
        await func(itemChunk);
    }
}
function distinct(values) {
    const valueSet = new Set();
    values.forEach(value => valueSet.add(value));
    return Array.from(valueSet);
}

const months = {
    0: 'Jan',
    1: 'Feb',
    2: 'Mar',
    3: 'Apr',
    4: 'May',
    5: 'Jun',
    6: 'Jul',
    7: 'Aug',
    8: 'Sep',
    9: 'Oct',
    10: 'Nov',
    11: 'Dec'
};
const dayOfWeek = {
    0: 'Sun',
    1: 'Mon',
    2: 'Tue',
    3: 'Wed',
    4: 'Thu',
    5: 'Fri',
    6: 'Sat'
};
/* Date Utilities */
/**
 * Checks if the date supplied is today
 * @param dt - A JavaScript Data
 * @returns boolean
 */
function isToday(dt) {
    const dt1 = luxon.DateTime.fromJSDate(dt).startOf('day');
    const now = luxon.DateTime.now().startOf('day');
    return dt1.diff(now, 'days').days === 0;
}
/**
 * Gets the number of milliseconds for today
 * @returns a number representing the current date in
 */
function today() {
    return luxon.DateTime.now().startOf('day').toMillis();
}
function startOf(unit, dt) {
    const value = dt ? luxon.DateTime.fromMillis(dt) : luxon.DateTime.now();
    return value.startOf(unit).toMillis();
}
function endOf(unit, dt) {
    const momentValue = dt ? luxon.DateTime.fromMillis(dt) : luxon.DateTime.now();
    return momentValue.endOf(unit).toMillis();
}
function formatShortMonthDayYear(dt) {
    return luxon.DateTime.fromMillis(dt).toFormat('DD');
}
function startOfMonth(dt) {
    return startOf('month', dt);
}
function endOfMonth(dt) {
    return endOf('month', dt);
}
function startOfYear(dt) {
    return startOf('year', dt);
}
function startOfWeek(dt) {
    return startOf('week', dt);
}
function endOfWeek(dt) {
    return endOf('week', dt);
}
function addDays(dt, numberOfDays) {
    const dateValue = isNumber(dt)
        ? luxon.DateTime.fromMillis(dt)
        : luxon.DateTime.fromJSDate(dt);
    return dateValue.plus({ days: numberOfDays }).toMillis();
}
/* end of date utilities */

function getRandomInt(max) {
    return Math.floor(Math.random() * Math.floor(max));
}
function getRandomNumber(length) {
    const numbers = [];
    for (let i = 0; i < length; i++) {
        numbers.push(getRandomInt(9));
    }
    return numbers.join();
}

function wait(ms) {
    return new Promise((resolve, reject) => {
        if (isNullOrUndefined(ms) || !isNumber(ms) || ms < 0) {
            reject('ms must be non-negative a number');
        }
        setTimeout(() => resolve(), ms);
    });
}

const emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,4}$/i;
const urlRegex = /^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?[a-z0-9]+([-.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/i;
/**
 * Formats a string and replaces the matching properties of the data with the value of the property e.g. Hi! {{ firstName }} or Hi {{ user.firstName }}
 * where firstName is a property of the data, and user is a nested object of the data with a firstName property.
 * @param template A string template using double curly braces to determine content to replace
 * @param data The data provided to the template
 * @returns
 */
function formatString(template, data = {}) {
    Object.keys(data).forEach(key => {
        const value = defaultIfEmpty(data, key);
        template = template.replace(new RegExp(`{{\\s*${key}\\s*}}`, 'g'), value);
    });
    return template;
}
/**
 * Checks if the value supplied is null, undefined, or whitespace
 * @param value A string value
 * @returns true if null, undefined, empty string, or only whitespace.
 */
function isEmptyOrWhiteSpace(value) {
    return isEmpty(value) || (isString(value) && value.replace(/\s+/g, '').length === 0);
}
function getFileExtension(fileName) {
    const indexOfExtension = fileName.lastIndexOf('.');
    if (indexOfExtension === -1) {
        throw new Error(`${fileName} does not have an extension`);
    }
    return fileName.substring(indexOfExtension);
}
function isEmail(email) {
    return !isNullOrUndefined(email)
        && emailRegex.test(email);
}
function isUrl(url) {
    return !isNullOrUndefined(url)
        && urlRegex.test(url);
}

exports.addDays = addDays;
exports.allEmpty = allEmpty;
exports.anyEmpty = anyEmpty;
exports.chunkAsync = chunkAsync;
exports.chunkMap = chunkMap;
exports.convertToQueryStringParams = convertToQueryStringParams;
exports.covertPartialToDotPathKeys = covertPartialToDotPathKeys;
exports.dayOfWeek = dayOfWeek;
exports.defaultIfEmpty = defaultIfEmpty;
exports.distinct = distinct;
exports.endOf = endOf;
exports.endOfMonth = endOfMonth;
exports.endOfWeek = endOfWeek;
exports.formatShortMonthDayYear = formatShortMonthDayYear;
exports.formatString = formatString;
exports.getFileExtension = getFileExtension;
exports.getNestedValue = getNestedValue;
exports.getRandomNumber = getRandomNumber;
exports.groupBy = groupBy;
exports.groupDictionary = groupDictionary;
exports.hasKeys = hasKeys;
exports.isBoolean = isBoolean;
exports.isEmail = isEmail;
exports.isEmpty = isEmpty;
exports.isEmptyOrWhiteSpace = isEmptyOrWhiteSpace;
exports.isFunction = isFunction;
exports.isNullOrUndefined = isNullOrUndefined;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPrimitive = isPrimitive;
exports.isString = isString;
exports.isToday = isToday;
exports.isUrl = isUrl;
exports.months = months;
exports.notEmpty = notEmpty;
exports.omit = omit;
exports.patchValues = patchValues;
exports.pick = pick;
exports.removeProperty = removeProperty;
exports.sortBy = sortBy;
exports.startOf = startOf;
exports.startOfMonth = startOfMonth;
exports.startOfWeek = startOfWeek;
exports.startOfYear = startOfYear;
exports.toDictionary = toDictionary;
exports.today = today;
exports.wait = wait;
